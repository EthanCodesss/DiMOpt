#+AUTHOR: Joao Salvado
#+TITLE: DiMOpt: A Distributed Multi-robot Trajectory Optimization algorithm


* Introduction
** Implemented Method Overview
This software implements a *Distributed Multi-robot  trajectory Optimization Algorithm* (DiMOpt) that deals with the problem of computing trajectories for multiple robots navigating in a shared space. This method exploits:
1. /Consensus optimization strategies/ to tackle collision constrains that couple robot's decision variables,
2. Single-robot /sequential convex programming/ (SCP) method for efficiently handling non-convexities introduced by dynamics.
** Simple Example
Trajectories computed at each iteration of the DiMOpt algorithm for a fleet of five robots.
#+BEGIN_html
 <img src="https://github.com/joaosalvado/DiMOpt/blob/main/images/transition.gif">
#+END_html


* Installation
** Dependencies
[[https://eigen.tuxfamily.org/dox/GettingStarted.html][Eigen3]]  [[https://docs.opencv.org/4.x/d0/d3d/tutorial_general_install.html][OpenCV]]
[[https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html][Threads]] [[https://www.open-mpi.org/][OpenMPI]]
#+begin_src sh
sudo apt update
sudo apt install python3
sudo apt install libeigen3-dev
sudo apt install libopencv-dev python3-opencv
sudo apt install libboost-thread-dev
sudo apt-get install -y libopenmpi-dev
#+end_src
*** CasADi
Casadi installation requires several steps that can be followed in [[https://github.com/casadi/casadi/wiki/InstallationLinux][link]].
Build casadi with IPOPT and HSL library ma27.
*** Matplot++
Choose your preferred installation method in [[https://github.com/alandefreitas/matplotplusplus#integration][link]]
** Build (CMake)
#+begin_src
mkdir build
cd build/
cmake ..
make
#+end_src

* Toy Example
#+begin_src cpp
#include <mropt/mropt.h>
#include <mropt/Problem/BuilderDistributedRobot_Dubins.h>

int main(int argc, char **argv) {

    // Initialisation OPENMPI
    MPI_Init(&argc, &argv);
    int r, size;
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &r);

    // 0 - Maps
    std::string maps_path = "../maps/";
    std::string map_file = "0.5pol.png";

    // 1 - Mission
    int N = 40;
    double T = 7;
    // 1.1) Starting Configuration (x, y, theta) for 3 robots
    std::vector<std::vector<double>> start =
            {
                    {1, 1, -0.5 * M_PI},
                    {3, 4, 0.5 * M_PI},
                    {1, 4, 0}
            };
    // 1.2) Goal Configuration (x,y, theta) for 3 robot
    std::vector<std::vector<double>> goal =
            {
                    {2, 2.5, 0},
                    {3, 2,   0},
                    {4, 1,   0}
            };
    // 1.3) Length and Width
    std::vector<double> L = {1,
                             0.6,
                             1.3};
    std::vector<double> W = {1, 0.6, 1.3};


    // Test MPI treads is equal to number of robots
    int R = start.size();
    if (size != R) {
        std::cerr << "Decoupled case must have R mpi thread!" << std::endl;
    }

    // 2 - Build a Robot
    mropt::Problem::BuilderDistributedRobot_Dubins builder_dubins_car;
    auto params = mropt::Problem::Robot::Params{0.0, T, N};
    auto sa = new ShapeArgs_type(); sa->L = L[r];
    builder_dubins_car.make_robot(r, sa, params);
    auto robot_d = builder_dubins_car.getDistributedRobot();
    // 3.2 - Assign missions to the robots
    robot_d->addMission(start[r], goal[r], {});

    // 4 -Solve
    // 4.1 - Setup Decoupled Plotter and Solver
    auto plotter = std::make_shared<mropt::util::Opencv_plotter>(R); // dummy
    plotter->setFootprint({L}, {W});
    plotter->addPathToScenarios(maps_path);
    plotter->inputScenario(map_file);

    mropt::Problem::DecoupledProblem mrprob_d{r};
    mrprob_d.setParams(R, N);
    mrprob_d.addRobot(robot_d);
    mrprob_d.set_plotter(plotter);
    mrprob_d.debug_mode().allow_plotting();

    // 4.2 - Solve
    try {
        mrprob_d.solve();
        mrprob_d.plot_trajectories(std::vector<std::shared_ptr<mropt::Dynamics::ode>>(R, robot_d->get_ode()));
        MPI_Barrier(MPI_COMM_WORLD);
    } catch (...) {
        std::exit(1); // terminate with exit code 1 = fail
    }

}
#+end_src

* Demo
There is a set of specially challenging problems with different number of robots that you can execute under the examples folder. For example:
#+begin_src sh
./square_sided_12.sh
#+end_src
